1. При відкритті сайту робиться два послідовних запита. 
Перший - на список жанрів, він після отримання зберігається у локальному сховищі як масив. 
Другий запит - на популярні фільми. Рендериться головна галерея через шаблонну функцію, та потім підключається пагінатор, 
який буде робити ці запити при переключенні сторінки.

2. При пошуку теж саме. Жанри вже є у сховищі. Робимо інший запит, рендеремо, підключаємо пагінатор, 
змінюючи його настройку на запит тільки якщо він успішний. Якщо неуспішний - месседж та залишається попередній відображений варіант.

3. При відкритті модалки зчитується id фільму із відповідного атрибуту (data-filmid) з картки розмітки. 
Для цього делегуємо обробку кліку на всю галерею, та визначаємо для елемента, по якому клікнули його предка 
(тобто найближчий вверх елемент розмітки) з класом .card - evt.target.closest(".card"); 
Після цього робимо запит на сервер за даними про цей конкретний фільм за його id. 
Тобто кожне відкриття картки з головної - запит на сервер по id. 
Чому не зберігаємо всі дані у сховищі - 1. Не хотіли роздувати сховище, бо спочатку не була пагінація готова, 
а нескінчений скрол означає безліч карток 2. Завжди маємо актуальні дані про фільм ) Ну і так набагато легче робити ))

4. Бібліотека зберігається у сховищі у двох об'єктах - watched та queue. 
Пагінація в бібліотеці - нескінчений скрол на обсервері. Чому не пагінатор - хотіли потренуватися на різних варіантах )) 
Одна сторінка - 9 фільмів, так гарніше для десктопу )

5. При відкритті модалки з бібліотеки запит на сервер не робимо, я дані беремо з бібліотеки також по id фільму (атрибут в .card)
Розмітку модалки також генерує загальна шаблонна функція, все централізовано.

6. Модалка при відкритті визначає, чи є фільм вже в просмотрених чи в черзі і відповідно налаштовує кнопки - add/remove. 
Можна зберігати фільм і там, і там, без обмеження. Це справа користувача, як казала ментор - подивився і хоче ще раз переглянути )

7. При натисканні на кнопку в модалці відбувається відповідна дія, об'єкт фільму додається чи видаляється з бібліотеки, 
бібліотека записується у сховище.

8. При закритті модалки (кнопка, ESC, клік по бекдропу), якщо були зміни в бібліотеці - її галерея перерендериться 
з урахуванням змін (видалили фільм). Якщо змін не було - нічого не робим, галерея лишається.

9. Дані для запису в бібліотеку беруться беспосередньо із розмітки модалки. Тобто, не запити, і не передача через сховище. 
Це зроблено по аналогії з формою, ніби модалка це як форма - інформацію беремо із її полів. 
Так робили, щоб не ускладнювати взаємодію між розробниками, бібліотека робилась раніше і не чекала, поки десь ці дані 
про конкретний фільм будут зберігатися. Ну і ймовірніть якихось проблем набагато менше )) 
Таким чином, бібліотека незалежна від апі - якщо дані вже відображені в модалці, то їх і записуємо.

10. Внутрішня реалізація бібліотеки. Бібліотека зроблена класом, створюється загальний об'єкт, який складається 
з двох об'єктів цього класу бібліотеки - watched і queue. Клас має інтерфейс для зчитування даних, видалення та додавання фільмів. 
Внутрішня логіка закрита у приватних полях та методах (#)

11. Чи на кнопках в модалці окремі, однакові за логікою, обробники (слухачи), тобто чи є дублювання коду? 
Ні, функція-обробник одна, вішається як слухач за допомогою прив'язки параметрів - bind, 
тобто в параметр функції-слухача заздалегідь прив'язуємо назву бібліоткеки, весь інший код - один, без дублювання.

12. Якщо картинки фільму немає на апі - в бібіотеці зберігаємо пустий рядок, при відображенні підміняємо його на картинку NoPoster
